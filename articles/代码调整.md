## 代码调整相关章节

### 代码调整方法总结
如果还对代码调整能否有助于提高某个程序的性能心存疑虑，按照以下的步骤去做吧。      
1. 用设计良好的代码来开发软件，从而使程序易于理解和修改。
2. 如果程序性能很差。    
   a.保存代码的可运行版本，这样你才能回到“最近的已知正常状态”；          
   b.对系统进行分析测量，找出热点；          
   c.判断性能拙劣是否源于设计、数据类型或算法上的缺陷，确定是否应该做代码调整，如果不是，请跳回第一步；  
   d.对步骤c中的所确定的瓶颈代码进行调整；   
   e.每次调整后都对性能提升进行测量；  
   f.如果调整没有改进代码的性能，就恢复到步骤a保存的代码（通常而言，超过一半的调整尝试都只能稍微改善性能甚至造成性能恶化）。
3. 重复步骤2。

### 代码调整技术
1. 逻辑
2. 循环
3. 数据变换
4. 表达式
5. 子程序
6. 用低级语言重写代码
7. 变得越多，事情反而越没变

#### 逻辑
**在知道答案后停止判断**             
一些语言提供了所谓的“短路求值”的表达式求值形式，这就意味着编译器所产生的代码一旦知道了判断的结果就会自动停止继续判断
。短路求值是C++标准运算符功能的一部分，Java的“条件（conditional）”运算符也是这样。    
          
一旦知道答案就停止判断的原则同样适用于其他很多场合。一种常见的情况就是搜索循环。如果你在一个存放属兔数据的数组中
寻找负数，并且仅仅需要知道是否有负数存在，那么有一种办法使检查每一个值，在找到负数后将negativeFound变量设置为
真。下面就是这种搜索方法。         
```c++
//C++示例：在知道答案之后不停下
negativeInputFound = false;
for (i = 0; i < count; i++) {
   if (input[i] < 0) {
      negativeInputFound = true;
   }
}
```

更好的方式是在找到负值后就立即停止查找。下面的任何一种方案都可以解决问题。      
- 在```negativeInputFound = true;```之后添加一个```break```语句。
- 如果你使用的语言不支持```break```,那么就用goto跳转到循环体结束后的第一行语句，模拟```break```的行为。
- 将for循环改为while循环，然后每次除了像for循环检查循环计数是否超过count外，还要检查negativeInputFound的值。
- 将for循环改为改为while循环，在输入数组的最后一项之后第一个空位置设置一个哨兵值（sentinel value），
然后简单地在while测试中检测负值。在循环结束后，看看首先发现的值是在原数组的范围内还是在哨兵位置。    
             
**按照出现的频率来调整判断顺序**         
安排判断的顺序，让运行最快和判断结果最有可能为真的判断首先执行。也就是说，让程序更容易进入常见情况的处理，如果有低效率的
情况，那就应该出现在处理非常见的情况时。这样的原则适用于case语句以及if-then-else语句串。     
             
下面就是一个Select-Case语句它负责在字处理程序中对键盘输入进行响应：          
``` 
Visual Basic示例：顺序差劲的逻辑判断
Select inputCharacter
   Case "+", "="
      ProcessMathSymbol(inputCharacter)
   Case "0" To "9"
      ProcessDigit(inputCharacter)
   Case ",", ".", ":", ";", "!", "?"
      ProcessPunctuation(inputCharacter)
   Case " "
      ProcessSpace(inputCharacter)
   Case "A" To "Z", "a" To "z"
      ProcessAlpha(inputCharacter)
   Case Else
      ProcessError(inputCharacter)
End Select
```
如果你能知道输入字符的出现频率，就可以把最常见的情况放在最前面。
```
Visual Basic示例：顺序合理的逻辑判断
Select inputCharacter
   Case "A" To "Z", "a" To "z"
         ProcessAlpha(inputCharacter)
   Case " "
         ProcessSpace(inputCharacter)
   Case ",", ".", ":", ";", "!", "?"
         ProcessPunctuation(inputCharacter)
   Case "0" To "9"
         ProcessDigit(inputCharacter)
   Case "+", "="
      ProcessMathSymbol(inputCharacter)
   Case Else
      ProcessError(inputCharacter)
End Select
```
在优化后的代码中，由于最常见的情况通常会很快发现，直接效果就是更少的判断所带来的性能提升。                          
               
| 语言 | 调整使用前 | 调整使用后 | 节省的时间 |   
| - | :-: | -: | -: |   
| C# | 0.220| 0.260 | -18% |   
| Java | 2.56 | 2.56 | 0% |   
| Visual Basic | 0.280 | 0.260 | 7% |        
       
MicroSoft Visual Basic的结果同预期相同，但Java和C#的表现却出乎我们的意料。显然，原因在于C#和Java中的switch-case语句的组织方式——每一个值都必须单独枚举出来，而不是放在一个范围中处理，因此，这两种语言无法像VB一样从这种优化中得到好处。这样的结果也强调了不要盲从于任何优化建议的重要性——特定编译器实现将会极大地影响到优化结果。     
            
或许你会认为，在VB编译器下，对一系列与上面case语句等价的if-then-else语句而言，优化所产生的效果是相似的。请看下面的结果：       
| 语言 | 调整使用前 | 调整使用后 | 节省的时间 |     
| - | :-: | -: | -: |   
| C# | 0.630| 0.330 | 48% |   
| Java | 0.922 | 0.460 | 50% |   
| Visual Basic | 1.36 | 1.00 | 26% |     
结果大不相同。对相同数量的判断，VB在代码优化前后所花费的时间是5:4。这表明编译器为case和if-then-else产生了不同的代码。            
        
对C#和VB来说，两者的case语句方案都会比各自的if-then-else方案要快，而在Java中，两个版本的case语句要慢一些。
         
**相似逻辑结构之间的性能比较**    
在一种语言中，case的效率显然高于if-then-else语句，而在另一种语言中，if-then-else语句又明显好于case。对第三种语言，两者不相上下。你或许还猜测，既然C#和Java的case语句语法相似，结果也应该差不多，但实际上它们却大相径庭。    
要实现代码调整中的某种“黄金法则”或是“逻辑准则”是很困难的——简而言之，没有什么能替代测量得出的结论。           
         
**用查询表替代负责的表达式（Substitute Table Lookups for Complicated Expressions）**         
在一些情况下，使用一张查询表会比穿梭在复杂的逻辑链路中更为高效。复杂逻辑链路的要点通常是对一些对象分类，然后根据类别采取相应动作。    
       
**使用惰性求值**       
惰性求值（Lazy evaluation）即是基于“如果那些事情根本就不重要，那么自然而然会在记忆中湮灭，也就没有必要去浪费时间了”原则。如果程序采用了这一方法，那么他就会避免做任何事情，直到迫不得已。
惰性求值类似于即时完成策略（just-in-time），即仅到工作必须完成的时候采取处理。          
         
#### 循环
**将判断外提（Unswitching）**     
切换（Switching）一词指代循环中的判断，该判断每次循环中都会被执行。如果在循环运行时某个判断结果不会改变，你就可以把这个判断提到循环的外面，从而避免在循环中进行判断。这样做时通常需要把循环的里面翻出来，把循环放在条件语句内，而不是把
条件语句放到循环内。下面的例子就是一个切换前的循环。
```c++
C++示例：在循环内判断
for(i = 0; i < count; i++){
   if(sumType == SUMTYPE_NET){
      netSum = netSum + amount[i];
   }
   else {
      grossSum = grossSum + amount[i];
   }
}
```
在这段代码中，测试语句`if(sumType == SUMTYPE_NET)`在每一次的循环中都会重复执行，尽管在整个循环中它都取相同的值。你可以用下面的方式重写代码，以获得性能提升：    
```c++
C++示例：将判断外提后的循环
if(sumType == SUMTYPE_NET) {
   for (i = 0; i < count; i++){
      netSum = netSum = amount[i];
   }
} else {
   for (i = 0; i < count; i++){
      grossSum = grossSum + amount[i];
   }
}
```
*注意：这段代码有悖于多条所提倡的编程规范。在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要，但本章的主题是性能，这也暗示了本章中提到的一些方法是以牺牲代码其他特性为代价的。*
         
**合并（Jamming）**      
合并（Jamming），或融合（fusion），就是把两个对相同一组元素进行操作的循环合并在一起。此举所带来的好处就是把两个循环的总开销减少至单个循环的开销。    
```
Visual Basic示例：可以合并的两个独立循环
For i = 0 to employeeCount - 1
    employeeName(i) = ""
Next
...
For i = 0 to emplyeeCount - 1 
    employeeEarnings(i) = 0;
Next
```
在合并循环的时候，你需要看到两个循环里的代码可以合而为一。通常而言，这意味着二者的循环计数器需要相同。    
```
Visual Basic示例：合并后的循环
For i = 0 to employeeCount - 1
    employeeName(i) = ""
    employeeEarnings(i) = 0
Next
```
循环合并有两种主要风险。首先，要合并的两个循环各自的下标又可能被改变，此后二者将无法共用一个循环下标。其次，你或许没有那么容易就能把循环合并在一起。在合并之前，你要保证合并后二者相对于其他代码的先后次序仍然正确。
         
**展开（Unrolling）**    
循环展开的目的是减少维护循环所需要做的工作。尽管完全展开循环是一种快速的解决办法，并且在对付少量元素时屡试不爽，但如果你遭遇大量元素或者无法预知元素数量，这样的方法就不适用了。
```java
//Java示例：可以展开的循环
int i = 0;
while(i < count){
  a[i] = i;
  i = i + 1;
}
```
要部分地将该循环展开，你要在每次遍历循环时进行两次或更多的处理而非一次。这样展开循环会损害程序可读性，但不影响循环的通用性。   
```java
//Java示例：展开一次后的循环
int i = 0;
while(i < count - 1){
  a[i] = i;
  a[i + 1] = i + 1;
  i = i + 2;
}
if(i == count - 1){
  a[count - 1] = count - 1;
}
```
这里的技术就是用两行语句替代了原来的a[i] = i， 并且i每次递增2而不是1。while循环后发附加代码处理，当count是奇数时，在循环结束后可能还要进行一次迭代。        
当区区5行直白代码被扩展为9行的技巧性代码之后，代码阅读和维护就更为困难了。抛开性能收益不谈，这段代码质量并不怎么样。然而，任何设计准则都包括权衡取舍的成分。
因此，尽管某种特定的方法通常被看做不良的编程实践，然而在特定场合下它仍是不二之选。    
```java
//Java示例：展开两次后的循环
int i = 0;
while(i < count - 2){
  a[i] = i;
  a[i + 1] = i + 1;
  a[i + 2] = i + 2;
  i = i + 3;
}
if(i <= count - 1){
  a[count - 1] = count - 1;
}
if(i == count - 2){
  a[count - 2] = count - 2;
}
```
结果表明，进一步的解循环能进一步地节省时间，但这并不是必然的。这种方法的主要问题是在于代码变得更诡异了。看看上面的代码，你或许认为看起来还不算绝顶复杂，但如果
到这段代码在几页之前仅仅是一个5行的循环，你就会更深刻地体会到性能和可读性之间的此消彼长了。      
**尽可能减少在循环内部做的工作**        
编写高效循环的关键在于尽可能减少循环内部所做的工作。如果你可以在循环外面计算某语句或某部分语句，而在循环内部只使用计算结果，那么就把它放到外面。这是一种很好的编程实践，在很多情况下
还可以改善程序的可读性。         
     
假设某频繁使用的循环，其内部有一个复杂的指针表达式，如下：   
```c++
//C++示例：循环内部的复杂 指针表达式
for(i = 0; i < rateCount; i ++) {
   netRate[i] = baseRate[i] * rates -> discounts -> factors -> net;
}
```
这时，把复杂的指针表达式赋给一个命名准确的变量，不但可以改善代码的可读性，还能提高代码的性能。
```c++
//C++示例：简化复杂的指针表达式
quantityDiscount = rates -> discounts -> factors -> net;
for(i = 0; i < rateCount; i ++) {
   netRate[i] = baseRate[i] * quantityDiscount;
}
```
所引用的新变量`quantityDiscount` 清楚地说明了 baseRate 数组中的元素逐个同数量折扣（quantity-discount）因子相乘，计算出了净费用。而在最初的循环表达式中，这样的含义并没有清晰地表达出来。
把复杂指针表达式转化为循环外变量，同样使得程序在每次循环时节省了指针三次解引用所花费的时间，由此带来改进。     
     
**哨兵值（Sentinel Values）**      
当循环的判断条件是一个复合判断的时候，你可以通过简化判断来节省代码运行时间。如果该循环是一个查找循环，简化方法之一就是使用一个哨兵值（sentinel value），你可以把它放到循环范围的末尾，从而保证循环一定
能够中止。           
例子：该循环一方面要检查它是否发现了所要找的值，另一方面要检查它是否遍历了所有的值。代码如下：
```c#
//C#示例：搜索循环中的组合判断
found = FALSE;
i = 0;
while((!found) && (i < count)) {
   if(item[i] == testValue) {
      found = TRUE;
   } else {
      i ++ ;
   }
}
if(found) {
...
}
```
在这段代码中，每次的循环迭代都要判断 !found 和 i < count 。前者判断是否找到了元素所需要的元素，后者避免循环超出数组末尾。在循环内部，每个 item[] 又要单独判断，
因此，对每一次迭代来说，循环中实际上有三次判断。          
在这种类型的查找循环里，你可以把三次判断合并起来，通过在查找范围末尾设置哨兵值的方式中止循环，使每一次的迭代只执行一次判断就可以了。你可以简单地把需要查找的值赋给超过查找范围之外的
那个元素（在声明数组的时候，切记为该元素留出空间），然后再去检查各个元素。如果是在数组的最后发现了你塞进去的元素，你会明白这实际上并不是需要查找的值。代码如下：     
```
C#示例：使用哨兵值来加速循环
// set snetinel value, preserving the original value
initialValue = item[count];
item[count] = testValue;

i = 0;
while(item[i] != testValue) {
    i ++;
}

// check if value was found 
if(i < count) {
...

```
          
**把最忙的循环放在最内层**     
在循环嵌套时，需要考虑把哪一个循环放在外面，哪一个放在里面。如例：    
```java
//Java 示例： 可以改进的嵌套循环
for(column = 0; column < 100; column ++) {
  for(row = 0; row < 5; row ++) {
    sum = sum + table[row][column];
  }
}
```
改进的关键在于解决外层循环执行的次数远远多于内层循环这一问题。每次执行的时候，循环都要初始化循环的下标，
在执行一遍循环代码后将它递增，然后进行检查。循环所执行的总次数是100次外部循环，100*5即500次内部循环，一共
是600次。如果把内外循环交换，那么将会是5次外部循环，5*100次内部循环，一共是505次。    
      
**削减强度**           
削减强度意味着用多次轻量级运算（例如加法）来代替一次代价高昂的运算（例如乘法）。有时，你的循环内部有一个表达式，
里面需要把循环下标同某个因子相乘。加法通常会比乘法快，因此如果你能够用每次迭代的数据相加得出相同的结果而避免使用
乘法，那么代码通常会快一些。使用乘法的例子如下：     
```
Visual Basic示例： 乘以循环下标
For i = 0 to saleCount - 1
   commossion(i) = (i + 1) * revenue * baseCommission * discount
Next
```
这段代码简单明了，但代价有些高。你可以重写这个循环，通过累加得到乘积，而不是每次去计算。      
```
Visual Basic示例：用加不用乘
incrementalCommission = revenue * baseCommission * discount
cumulativeCommission = incrementalCommission
For i = 0 to saleCount - 1
   commission(i) = cumulativeCommission
   cumulativeCommission = cumulativeCommission + incrementalCommission
Next
```
使用乘法的代价十分昂贵。这样的改变就像是商家的优惠券，让你在为循环所支付的费用上打个折。在最初的代码中，i的每次迭代都会增加，并且
需要乘以revenue、baseCommission和discount，首先是1，接下来是2，然后是3，这样继续下去。优化之后，incrementalCommission就等于
revenue。代码会在每一次循环时把incrementalCommission加到cumulativeCommission上面。在第一次遍历的时候，需要加一次，第二次的时候
已经加了两次，第三次的时候就已经加了三次，以此类推。这样的效果同incrementalCommission乘以1、乘以2、乘以3等的效果相同，但代价低很多。    
     
#### 数据变换
数据类型的改变同样可以减少程序规模和改进执行速度方面的利器。      
**使用整型数而不是浮点数**     
整型数的加法和乘法要比浮点数的相应运算快很多。因此，例如把循环下标从浮点类型改为整型这样的方法能够为代码运行节省很多时间：   
```
Visual Basic示例：使用耗时的浮点循环下标
Dim x As Single
For x = 0 to 99
   a(x) = 0
Next
```
与之相对，使用整型下标的Visual Basic循环：    
```
Visual Basic示例：使用省时的整数循环下标
Dim i As Integer
For i = 0 to 99
   a(i) = 0
Next
```
        

**数组维度尽可能少**     
多年来积累的编程智慧表明，处理多维数组的代价是惊人的。如果你使用一维数组组织你的数据而非二维或三维，或许能够节省一些时间。        
        
**尽可能减少数组引用**      
除了避免对二维或三维数组的访问，减少对数组的访问总是有好处的。用这种方法对付重复使用数组里同一元素的循环就是很好的选择。下面的例子
使用了不必要的数组访问：            
```
//C++示例：在循环内部不必要地引用数组元素
for(discountType = 0; discountType < typeCount; discountType ++) {
    for(discountLevel = 0; discountLevel < levelCount; discountLevel ++) {
        rate[discountLevel] = rate[discountLevel] * discount[discountType];
    }
}
```
在内层循环中，虽然discountLevel发生了改变，但对discount[discountType]的引用就没有变。因此你可以把它从内层循环里面提取出来，这样每次外层循环
中就只需执行一次数组访问，而不是在每次内层循环中都要执行一次数组访问。
```
//C++示例：将数组引用提出循环
for(discountType = 0; discountType < typeCount; discountType ++) {
    thisDiscount = discount[discountType];
    for(discountLevel = 0; discountLevel < levelCount; discountLevel ++) {
        rate[discountLevel] = rate[discountLevel] * thisDiscount;
    }
}
```
      
**使用辅助索引**       
使用辅助索引的意思就是添加相关数据，使得对某种数据类型的访问更为高效。你可以把相关数据添加到主数据类型中，或者存放到并行结构中。     
1. 字符串长度索引         
你可以在不同的字符串存储策略中发现辅助索引的身影。在C语言中，字符串是被一个值为0的字节中止。对Visual Basic字符串而言，在每个字符串的开始位置隐藏
有一个长度字节，标识该字符串的长度。要确定C语言字符串的长度，程序需要从字符串开始位置对各个字节计数，直到发现0的字节为止。要确定Visual Basic字符
长度，程序只需要看那看看你长度字节就可以了。Visual Basic长度字节就是一个例子，说明给程序结构增加一个索引，有可能让一些特定的操作——例如计算字符
串长度——变得更快。      
你可以把这种为长度添加索引的思想应用到任何可变长度的数据类型上面。在需要知道数据长度的时候，相对于临时计算，提早维护这样的结构长度数据显然更为有效。      
2. 独立的平行的索引结构    
有时，与操作数据类型本身相比，操作数据类型的索引会更为有效。尤其是如果数据类型中的条目很大或是难于移动（或许存放在磁盘上），那么对索引排序和查找会比
直接对数据进行相同操作要快。当每一个数据条目都很大的时候，你可以创建一个辅助结构，里面存放关键码和指向详细信息的指针。如果数据结构条目和辅助结构条目
的大小差异足够显著，你可以把关键条目存放在内存里，而把数据存放在外部。这使所有的查找和排序都在内存里完成，知道了所需访问条目的具体地址之后，进行一次
磁盘访问就够了。          
        
**使用缓存机制（Use Caching）**    
缓存机制就是把某些值存起来，使得最常用的值更容易被获取。     
除了用来磁盘上的记录，缓存机制还能用到其他领域。在Microsoft Windows的字体描绘程序中，一度的性能瓶颈就是在显示每一个字符的时候获取字符宽度。在将
最近所使用的字符宽度缓存之后，显示速度即提升了大约一倍。       
你也可以缓存那些需要消耗大量时间进行计算的结果——尤其是在参与计算的参数很简单的时候。      
缓存的成功取决于访问被缓存元素、创建未缓存元素，以及在缓存中保存新元素等动作相关的代价，同样，缓存信息被请求访问的频率也是重要的元素。在某些情况下，
成功或许还依赖于硬件所做的缓存。一般而言，如果创建新元素的代价越大，请求相同信息的次数越多，那么缓存就越有价值。同样，访问缓存元素或将新元素存放到
缓存中的开销越小，缓存体现出的价值就越大。同其他优化技术一样，缓存增加了程序的复杂性，使得程序容易出错。          




























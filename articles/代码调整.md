## 代码调整相关章节

### 代码调整方法总结
如果还对代码调整能否有助于提高某个程序的性能心存疑虑，按照以下的步骤去做吧。      
1. 用设计良好的代码来开发软件，从而使程序易于理解和修改。
2. 如果程序性能很差。    
   a.保存代码的可运行版本，这样你才能回到“最近的已知正常状态”；          
   b.对系统进行分析测量，找出热点；          
   c.判断性能拙劣是否源于设计、数据类型或算法上的缺陷，确定是否应该做代码调整，如果不是，请跳回第一步；  
   d.对步骤c中的所确定的瓶颈代码进行调整；   
   e.每次调整后都对性能提升进行测量；  
   f.如果调整没有改进代码的性能，就恢复到步骤a保存的代码（通常而言，超过一半的调整尝试都只能稍微改善性能甚至造成性能恶化）。
3. 重复步骤2。

### 代码调整技术
1. 逻辑
2. 循环
3. 数据变换
4. 表达式
5. 子程序
6. 用低级语言重写代码
7. 变得越多，事情反而越没变

#### 逻辑
**在知道答案后停止判断**             
一些语言提供了所谓的“短路求值”的表达式求值形式，这就意味着编译器所产生的代码一旦知道了判断的结果就会自动停止继续判断
。短路求值是C++标准运算符功能的一部分，Java的“条件（conditional）”运算符也是这样。    
          
一旦知道答案就停止判断的原则同样适用于其他很多场合。一种常见的情况就是搜索循环。如果你在一个存放属兔数据的数组中
寻找负数，并且仅仅需要知道是否有负数存在，那么有一种办法使检查每一个值，在找到负数后将negativeFound变量设置为
真。下面就是这种搜索方法。         
```c++
//C++示例：在知道答案之后不停下
negativeInputFound = false;
for (i = 0; i < count; i++) {
   if (input[i] < 0) {
      negativeInputFound = true;
   }
}
```

更好的方式是在找到负值后就立即停止查找。下面的任何一种方案都可以解决问题。      
- 在```negativeInputFound = true;```之后添加一个```break```语句。
- 如果你使用的语言不支持```break```,那么就用goto跳转到循环体结束后的第一行语句，模拟```break```的行为。
- 将for循环改为while循环，然后每次除了像for循环检查循环计数是否超过count外，还要检查negativeInputFound的值。
- 将for循环改为改为while循环，在输入数组的最后一项之后第一个空位置设置一个哨兵值（sentinel value），
然后简单地在while测试中检测负值。在循环结束后，看看首先发现的值是在原数组的范围内还是在哨兵位置。    
             
**按照出现的频率来调整判断顺序**         
安排判断的顺序，让运行最快和判断结果最有可能为真的判断首先执行。也就是说，让程序更容易进入常见情况的处理，如果有低效率的
情况，那就应该出现在处理非常见的情况时。这样的原则适用于case语句以及if-then-else语句串。     
             
下面就是一个Select-Case语句它负责在字处理程序中对键盘输入进行响应：          
``` 
Visual Basic示例：顺序差劲的逻辑判断
Select inputCharacter
   Case "+", "="
      ProcessMathSymbol(inputCharacter)
   Case "0" To "9"
      ProcessDigit(inputCharacter)
   Case ",", ".", ":", ";", "!", "?"
      ProcessPunctuation(inputCharacter)
   Case " "
      ProcessSpace(inputCharacter)
   Case "A" To "Z", "a" To "z"
      ProcessAlpha(inputCharacter)
   Case Else
      ProcessError(inputCharacter)
End Select
```
如果你能知道输入字符的出现频率，就可以把最常见的情况放在最前面。
```
Visual Basic示例：顺序合理的逻辑判断
Select inputCharacter
   Case "A" To "Z", "a" To "z"
         ProcessAlpha(inputCharacter)
   Case " "
         ProcessSpace(inputCharacter)
   Case ",", ".", ":", ";", "!", "?"
         ProcessPunctuation(inputCharacter)
   Case "0" To "9"
         ProcessDigit(inputCharacter)
   Case "+", "="
      ProcessMathSymbol(inputCharacter)
   Case Else
      ProcessError(inputCharacter)
End Select
```
在优化后的代码中，由于最常见的情况通常会很快发现，直接效果就是更少的判断所带来的性能提升。                          
               
| 语言 | 调整使用前 | 调整使用后 | 节省的时间 |   
| - | :-: | -: | -: |   
| C# | 0.220| 0.260 | -18% |   
| Java | 2.56 | 2.56 | 0% |   
| Visual Basic | 0.280 | 0.260 | 7% |        
       
MicroSoft Visual Basic的结果同预期相同，但Java和C#的表现却出乎我们的意料。显然，原因在于C#和Java中的switch-case语句的组织方式——每一个值都必须单独枚举出来，而不是放在一个范围中处理，因此，这两种语言无法像VB一样从这种优化中得到好处。这样的结果也强调了不要盲从于任何优化建议的重要性——特定编译器实现将会极大地影响到优化结果。     
            
或许你会认为，在VB编译器下，对一系列与上面case语句等价的if-then-else语句而言，优化所产生的效果是相似的。请看下面的结果：       
| 语言 | 调整使用前 | 调整使用后 | 节省的时间 |     
| - | :-: | -: | -: |   
| C# | 0.630| 0.330 | 48% |   
| Java | 0.922 | 0.460 | 50% |   
| Visual Basic | 1.36 | 1.00 | 26% |     
结果大不相同。对相同数量的判断，VB在代码优化前后所花费的时间是5:4。这表明编译器为case和if-then-else产生了不同的代码。            
        
对C#和VB来说，两者的case语句方案都会比各自的if-then-else方案要快，而在Java中，两个版本的case语句要慢一些。
         
**相似逻辑结构之间的性能比较**    
在一种语言中，case的效率显然高于if-then-else语句，而在另一种语言中，if-then-else语句又明显好于case。对第三种语言，两者不相上下。你或许还猜测，既然C#和Java的case语句语法相似，结果也应该差不多，但实际上它们却大相径庭。    
要实现代码调整中的某种“黄金法则”或是“逻辑准则”是很困难的——简而言之，没有什么能替代测量得出的结论。           
         
**用查询表替代负责的表达式（Substitute Table Lookups for Complicated Expressions）**         
在一些情况下，使用一张查询表会比穿梭在复杂的逻辑链路中更为高效。复杂逻辑链路的要点通常是对一些对象分类，然后根据类别采取相应动作。    
       
**使用惰性求值**       
惰性求值（Lazy evaluation）即是基于“如果那些事情根本就不重要，那么自然而然会在记忆中湮灭，也就没有必要去浪费时间了”原则。如果程序采用了这一方法，那么他就会避免做任何事情，直到迫不得已。
惰性求值类似于即时完成策略（just-in-time），即仅到工作必须完成的时候采取处理。          
         
#### 循环
**将判断外提（Unswitching）**     
切换（Switching）一词指代循环中的判断，该判断每次循环中都会被执行。如果在循环运行时某个判断结果不会改变，你就可以把这个判断提到循环的外面，从而避免在循环中进行判断。这样做时通常需要把循环的里面翻出来，把循环放在条件语句内，而不是把
条件语句放到循环内。下面的例子就是一个切换前的循环。
```c++
C++示例：在循环内判断
for(i = 0; i < count; i++){
   if(sumType == SUMTYPE_NET){
      netSum = netSum + amount[i];
   }
   else {
      grossSum = grossSum + amount[i];
   }
}
```
在这段代码中，测试语句`if(sumType == SUMTYPE_NET)`在每一次的循环中都会重复执行，尽管在整个循环中它都取相同的值。你可以用下面的方式重写代码，以获得性能提升：    
```c++
C++示例：将判断外提后的循环
if(sumType == SUMTYPE_NET) {
   for (i = 0; i < count; i++){
      netSum = netSum = amount[i];
   }
} else {
   for (i = 0; i < count; i++){
      grossSum = grossSum + amount[i];
   }
}
```
*注意：这段代码有悖于多条所提倡的编程规范。在很多情况下，代码的可读性和可维护性都要比运行速度或资源占用更为重要，但本章的主题是性能，这也暗示了本章中提到的一些方法是以牺牲代码其他特性为代价的。*
         
**合并（Jamming）**      
合并（Jamming），或融合（fusion），就是把两个对相同一组元素进行操作的循环合并在一起。此举所带来的好处就是把两个循环的总开销减少至单个循环的开销。    
```
Visual Basic示例：可以合并的两个独立循环
For i = 0 to employeeCount - 1
    employeeName(i) = ""
Next
...
For i = 0 to emplyeeCount - 1 
    employeeEarnings(i) = 0;
Next
```
在合并循环的时候，你需要看到两个循环里的代码可以合而为一。通常而言，这意味着二者的循环计数器需要相同。    
```
Visual Basic示例：合并后的循环
For i = 0 to employeeCount - 1
    employeeName(i) = ""
    employeeEarnings(i) = 0
Next
```
循环合并有两种主要风险。首先，要合并的两个循环各自的下标又可能被改变，此后二者将无法共用一个循环下标。其次，你或许没有那么容易就能把循环合并在一起。在合并之前，你要保证合并后二者相对于其他代码的先后次序仍然正确。
         
**展开（Unrolling）**    
循环展开的目的是减少维护循环所需要做的工作。尽管完全展开循环是一种快速的解决办法，并且在对付少量元素时屡试不爽，但如果你遭遇大量元素或者无法预知元素数量，这样的方法就不适用了。
```java
//Java示例：可以展开的循环
int i = 0;
while(i < count){
  a[i] = i;
  i = i + 1;
}
```
要部分地将该循环展开，你要在每次遍历循环时进行两次或更多的处理而非一次。这样展开循环会损害程序可读性，但不影响循环的通用性。   
```java
//Java示例：展开一次后的循环
int i = 0;
while(i < count - 1){
  a[i] = i;
  a[i + 1] = i + 1;
  i = i + 2;
}
if(i == count - 1){
  a[count - 1] = count - 1;
}
```
这里的技术就是用两行语句替代了原来的a[i] = i， 并且i每次递增2而不是1。while循环后发附加代码处理，当count是奇数时，在循环结束后可能还要进行一次迭代。        
当区区5行直白代码被扩展为9行的技巧性代码之后，代码阅读和维护就更为困难了。抛开性能收益不谈，这段代码质量并不怎么样。然而，任何设计准则都包括权衡取舍的成分。
因此，尽管某种特定的方法通常被看做不良的编程实践，然而在特定场合下它仍是不二之选。    
```java
//Java示例：展开两次后的循环
int i = 0;
while(i < count - 2){
  a[i] = i;
  a[i + 1] = i + 1;
  a[i + 2] = i + 2;
  i = i + 3;
}
if(i <= count - 1){
  a[count - 1] = count - 1;
}
if(i == count - 2){
  a[count - 2] = count - 2;
}
```
结果表明，进一步的解循环能进一步地节省时间，但这并不是必然的。这种方法的主要问题是在于代码变得更诡异了。看看上面的代码，你或许认为看起来还不算绝顶复杂，但如果
到这段代码在几页之前仅仅是一个5行的循环，你就会更深刻地体会到性能和可读性之间的此消彼长了。      
**尽可能减少在循环内部做的工作**        
编写高效循环的关键在于尽可能减少循环内部所做的工作。如果你可以在循环外面计算某语句或某部分语句，而在循环内部只使用计算结果，那么就把它放到外面。这是一种很好的编程实践，在很多情况下
还可以改善程序的可读性。         
     
假设某频繁使用的循环，其内部有一个复杂的指针表达式，如下：   
```c++
//C++示例：循环内部的复杂 指针表达式
for(i = 0; i < rateCount; i ++) {
   netRate[i] = baseRate[i] * rates -> discounts -> factors -> net;
}
```
这时，把复杂的指针表达式赋给一个命名准确的变量，不但可以改善代码的可读性，还能提高代码的性能。
```c++
//C++示例：简化复杂的指针表达式
quantityDiscount = rates -> discounts -> factors -> net;
for(i = 0; i < rateCount; i ++) {
   netRate[i] = baseRate[i] * quantityDiscount;
}
```
所引用的新变量`quantityDiscount` 清楚地说明了 baseRate 数组中的元素逐个同数量折扣（quantity-discount）因子相乘，计算出了净费用。而在最初的循环表达式中，这样的含义并没有清晰地表达出来。
把复杂指针表达式转化为循环外变量，同样使得程序在每次循环时节省了指针三次解引用所花费的时间，由此带来改进。     
     
**哨兵值（Sentinel Values）**      
当循环的判断条件是一个复合判断的时候，你可以通过简化判断来节省代码运行时间。如果该循环是一个查找循环，简化方法之一就是使用一个哨兵值（sentinel value），你可以把它放到循环范围的末尾，从而保证循环一定
能够中止。           
例子：该循环一方面要检查它是否发现了所要找的值，另一方面要检查它是否遍历了所有的值。代码如下：
```c#
//C#示例：搜索循环中的组合判断
found = FALSE;
i = 0;
while((!found) && (i < count)) {
   if(item[i] == testValue) {
      found = TRUE;
   } else {
      i ++ ;
   }
}
if(found) {
...
}
```
在这段代码中，每次的循环迭代都要判断 !found 和 i < count 。前者判断是否找到了元素所需要的元素，后者避免循环超出数组末尾。在循环内部，每个 item[] 又要单独判断，
因此，对每一次迭代来说，循环中实际上有三次判断。          
在这种类型的查找循环里，你可以把三次判断合并起来，通过在查找范围末尾设置哨兵值的方式中止循环，使每一次的迭代只执行一次判断就可以了。你可以简单地把需要查找的值赋给超过查找范围之外的
那个元素（在声明数组的时候，切记为该元素留出空间），然后再去检查各个元素。如果是在数组的最后发现了你塞进去的元素，你会明白这实际上并不是需要查找的值。代码如下：     
```
C#示例：使用哨兵值来加速循环
// set snetinel value, preserving the original value
initialValue = item[count];
item[count] = testValue;

i = 0;
while(item[i] != testValue) {
    i ++;
}

// check if value was found 
if(i < count) {
...

```













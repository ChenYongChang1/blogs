### 第3章  权责让渡

函数式思维的好处之一，是能够将低层次细节（如垃圾收集）的控制权移交给运行时，从而消弭了一大批注定会发生的程序错误。开发者们可以一边熟视无睹地享受着最基本的抽象，比如内存，一边却会对更高层次的抽象感觉突兀。。然而不管层次高低，抽象的目的总是一样的：让开发者从繁琐的运作细节里解脱出来，去解答问题中非重复性的那些方面。


####  3.1 迭代让位于高阶函数

理解掌握的抽象层次永远要比日常使用的抽象层次更深一层。

程序员的工作效率依赖于抽象层，好比没有人会直接翻弄硬盘上或0或1磁盘记录来给计算机编程。抽象隐藏了繁杂的细节，只是有时候会连同重要的考虑因素一起隐藏掉。


#### 3.2 闭包

闭包(closure)是所有函数式语言都具备的一项平常特性，可是相关的论述却常常充斥着晦涩乃至神秘的字眼。
所谓闭包，实际上是一种特殊的函数，它在暗地里绑定了函数内部引用的所有变量。换句话说，这种函数（或方法）把它引用的所有东西都放在一个上下文里“包”了起来。

*Groovy语言中闭包绑定的简单示例*

```groovy
class Employee {
    def name, salary
}

def paidMore(amount) {
    return {Employee e -> e.salary > amount}
}

isHighPaid = paidMore(100000)
```
首先定义了一个简单的Employee类，类中带了两个字段。接着定义带有amount参数的paidMore函数，其返回值是一个以Employee实例为参数的代码块，或者叫闭包。
类型声明Employee可写可不写，这里写出来顺便起到文档的作用。接下来，我们给代码块传入参数值100000，并赋予isHighPaid的名称，于是数值100000就随着这一步赋值操作，永久地和代码块绑定在一起了。以后有员工数据被带入这个代码块求解的时候，它就可以拿绑定的数值作为标准去评判员工的工资高低。

*执行闭包*

```groovy
def Smithers = new Emplyee(name: "Fred", salary: 120000)
def Homer = new Employee(name: "Homer", salary: 80000)
println isHighPaid(Smithers)
println isHighPaid(Homer)
// true, false
```
本例创建了两笔员工数据，然后判断其工资是否达到标准线。闭包在生成的时候，会把引用的变量全部圈到代码块的作用域里，封闭、包围起来（故名闭包）。
闭包的每个实例都保有自己的一份变量取值，包括私有变量也是如此。也就是说，我们可以创建paidMore闭包的另一个实例，给它绑定另外的数值（当然实例的名字也要另取）。

*绑定另一个闭包*

```groovy
isHigherPaid = paidMore(200000)
println isHigherPaid(Smithers)
println isHigherPaid(Homer)
def Burns = new Employee(name: "Monty", salary: 1000000)
println isHigherPaid(Burns)
// false, false, true
```
闭包经常被函数式语言和框架当成是一种异地执行的机制，用来传递待执行的变换代码，如map()之类的高阶函数。在缺乏闭包特性的旧版Java平台上，Functional Java利用匿名内部类来模仿“真正的”闭包的某些行为，但语言的先天不足导致这种模仿是不彻底的。

*闭包的原理（Groovy示例）*
```groovy
def Cloure makeCounter() {
  def local_variable = 0
  return {return local_variable += 1}  // ①
}

c1 = makeCounter()  //②
c1()               // ③
c1()
c1()

c2 = makeCounter()     // ④

println "C1 = ${c1()}, C2 = ${c2()}"
// output:C1 = 4, C2 = 1 ⑤
```
- ①函数的返回值是一个代码块，而不是一个值
- ②c1现在只想代码块的一个实例
- ③调用c1将递增其内部变量，如果这个时候输出，其结果也会是1
- ④c2现在指向makeCounter()的一个全新实例，与其他实例没有关联
- ⑤每个实例的内部状态都是独立的，各自拥有一份local_variable

makeCounter()函数首先定义一个局部变量，明白无误地命名为local_variable，接着返回一个使用了该局部变量的代码块。注意makeCounter()函数的返回类型是Closure，而不是一个单穿的值。
代码块的工作仅仅是递增并返回其局部变量的值。方法中两次明确写出了return关键字，其实这两个地方Groovy都允许省略，不过那样的话，代码看起来就有些晦涩了。

为了演示makeCounter()函数的用法，我们给代码块分配了一个变量名c1，然后调用了三次。调用代码块的时候用到了Groovy提供的语法糖衣，也就是在代码块变量名后直接跟一对圆括号的写法（否则应该写成c1.call()）。接下来，我们第二次调用了makeCounter()，将返回的又一个代码块实例赋给变量c2.最后我们把c1和c2都调用了一次。
从运行结果来看，两个代码块实例都分别持有自己的一份local_variable变量。“闭包”这个名字来源于它创建*封闭上下文*的行为。虽然局部变量不是在代码块里面定义的，但只要代码块引用了该变量，两者就被绑定在一起，这种联系在代码块实例的全部生命期内都一直保持着。

从实现的角度来说，代码块实例从它被创建的一刻起，就持有其作用域内的一切事物的封闭副本。当代码块实例被垃圾收集的时候，它持有的引用也同时被回收。

闭包在这里表现出的函数式思维就是“让运行时去管理状态”。

**让语言去管理状态。**

闭包还是*推迟执行*原则的绝佳样板。我们把代码绑定到闭包之后，可以推迟到适当的时机再执行闭包。这个特点在很多场合都能发挥作用。例如必要的变量和函数可能并不在定义时的作用域里，要到执行的时候才准备好。那么我们把执行上下文放在闭包里保留起来，就可以等到正确的时机再完成执行。

命令式语言围绕状态来建立编程模型，参数传递是其典型特征。闭包作为一种对行为的建模手段，让我们把代码和上下文同时封装在单一结构，也就是闭包本身里面，像传统数据结构一样可以传递到其他位置，然后在恰当的时间和地点完成执行。

**抓住上下文，而非状态。**

#### 3.3 柯里化和函数的部分施用

柯里化（currying）和函数的部分施用（partial application）都是从数学里借用过来的编程语言技法。柯里化和函数部分施用都有能力操纵函数或方法的参数数目，一般是通过向一部分参数代入一个或多个默认值的办法来实现的（这部分参数被称为“固定参数”）。

##### 3.3.1  定义与辨析
乍看起来，柯里化和部分施用的使用效果是一样的。两者都可以创建有一部分预设参数值的函数。

柯里化指的是从一个多函数变成一连串单参数函数的变换。它描述的是变换的过程，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生为一个参数数目较少的新函数。

部分施用指通过提前代入一部分参数值，使一个多参数得意省略部分参数，从而转化为一个参数数目较少的函数。这种技法叫作“部分施用”，顾名思义，就是让函数先作用于其中一些参数，经过部分的求解，结果返回一个由余下参数构成签名的函数。

柯里化和部分施用都是在我们提供部分参数值之后，产出可以凭余下参数实施调用的一个函数。不同的地方在于，函数柯里化的结果是返回链条中下一个函数，而部分施用是把参数的取值绑定到用户在操作中提供的具体值上，因而产生一个“元数”（参数的数目）较少的函数。用元数大于二的函数来套一下这里的解释，它们之间的区别就会比较清楚了。

举个例子，函数process(x, y, z)完全柯里化之后将变成process(x)(y)(z)的形式，其中process(x)和process(x)(y)都是单参数的函数。
如果只对第一个参数柯里化，那么process(x)的返回值将是一个单参数的函数，而这个唯一的参数又接受另一个参数的输入。
而部分施用的结果直接是一个减少了元数的函数。如果在process(x, y, z)上部分施用一个参数，那么我们将得到还剩下两个参数的函数：process(y, z).

##### 3.3.2 Groovy的情况
Groovy通过curry()函数实现柯里化，这个函数来自Closure类。

*Groovy语言中的柯里化*

```groovy
def product = {x, y -> x * y}

def quadrate = product.curry(4)      //①
def octate = product.curry(8)        //②

println "4×4：${quadrate.call(4)}"   //③
println "8×5：${octate(5)}"          //④
```
- ①调用curry()来固定一个参数，返回结果是一个单参数的函数。
- ②octate()函数总是对传入的参数乘以8.
- ③quadrate()是一个单参数的函数，可以通过Closure类的call()方法来调用它。
- ④Groovy提供了一层语法 糖衣，可以让调用语句的写法更自然一些。

本例首先定义接受两个参数的代码块product。利用Groovy内建的curry()方法，在product的基础上构造出两个新的代码块，quadrate和octate。
Groovy为调用代码块提供了特别的便利，我们既可以执行call()方法，也可以使用Groovy在语言层面提供的语法糖衣，也就是在代码块的名称后面紧跟一对圆括号，参数则写在括号里。

curry()虽然叫这个名字，它在背后对代码块所做的事情其实属于函数的部分施用。尽管名不符实，但用它来模拟出柯里化的效果还是可行的。做法是通过连续的部分施用使函数变形为一连串单参数的函数，如下。

*Groovy语言中部分施用与柯里化的对比*

```groovy
def volume = {h, w, l -> h * w * l}
def area = volume.curry(1)
def lengthPA = volume.curry(1, 1)         //①
def lengthC = volume.curry(1).curry(1)    //②

println "参数取值为2×3×4的长方体，体积为${volume(2, 3, 4)}"
println "参数取值为3×4的长方形，面积为${area(3, 4)}"
println "参数取值为6的线段，长度为${lengthPA(6)}"
println "参数取值为6的线段，经柯里化函数求得的长度为${lengthC(4)}"
```
- ①部分施用
- ②柯里化

两种写法只有微妙的区别，最终的计算结果也完全相同，但如果你在一名函数式程序员面前不加区分地使用这两个名词，他一定会纠正你。很不幸，Groovy把这两个密切相关的概念混为一谈了。

函数式编程赋予我们另一套新的构造单元，代替以往命令式语言所使用的机制来完成相同的目标。这些构造单元之间的关系经过了细致的安排。复合（composition），是函数式语言拼组这些构造单元的一般方式。

##### 3.3.5 一般用途
1. 函数工厂

我们在传统面向对象编程中会用到工厂方法的场合，正适合柯里化（以及部分施用）表现它的才干。如下，Groovy实现的加法函数和递增函数。

```groovy
def adder = {x, y -> x + y}
def incrementer = adder.curry(1)

println "incrementer 7 : ${incrementer(7)}"   //8
```
例中从adder()函数派生出了incrementer函数。

2. Template Method模式

GoF模式集里面有一项Template Method（模板方法）模式。其用意是在固定的算法框架内部安排一些抽象方法，为后续的具体实现保留一部分的灵活性。部分施用和柯里化也可以起到相同的作用。部分施用技法注入当前已经确定的行为，留下未确定的参数给具体实现去发挥，其思路与模板方法这种面向对象的设计模式如出一辙。

第6章将会用一个例子来说明，若干模式（包括模板方法模式在内）怎样因为部分施用和其他函数式技法而失去了存在意义。

3. 隐含参数

当我们需要频繁调用一个函数，而每次的参数值都差不多的时候，可以运用柯里化来设置隐含参数。举个例子，我们在操作持久化框架的时候，每次都要在第一个参数里写上数据源的位置。而经过部分施用以后，就不需要反复地写出这个参数值了。

*运用部分施用技法设置隐含参数值*

```
(defn db-connect[data-source query params]
    ...)
    
(def dbc (partial db-connect "db/some-data-source"))

(dbc "select * from %1" "cust") 
```
dbc函数在操作数据的时候不需要在提供数据源，数据源已经自动设置好了。面向对象编程中“封装”概念的本质，也就是魔术般出现在每个函数里的隐含上下文this，我们可以在函数式编程中加以模拟，用柯里化的方式吧this传递给所有的函数，让this在使用这的面前隐藏起来。

#### 3.4 递归
递归，按照维基百科的定义，是“一种自相似的方式来重复事物的过程”。它也是我们想运行时托付操作细节的一个例子，而且和函数式编程有着极为密切的联系。
以具体的时间来说，递归是以一种带点计算机科学味道的方式来对一组事物进行迭代，让事物的集合反复对自身调用同样的方法，使集合随着每次迭代不断缩小，同时要始终小心地保证退出条件的有效性。
很多时候，我们的问题核心就是对一个不断变短的列表反复做同一件事。



## 第4章   用巧不用蛮
我们转换范式的收获，表现在费更少的力气完成更多的事情。很多函数式编程构造的目的只有一个：从频繁出现的场景中消灭掉烦人的实现细节。

#### 4.1 记忆






















